#include "USB_HID.h"
#include <delays.h>

void setup(void);
void loop(void);
void processUsbCommands(void);
void executeDigitalWrite(void);
void executePinMode(void);
WORD_VAL ReadADC(short);
void sendAnalogInputs(void);

int tick = 0;

void delay(void)
{
	int i;
	for (i=0; i<=1; i++)
	 {
	      Delay10KTCYx(250);   // Delay of 10000*250 Cycles
	 }
}

WORD_VAL ReadADC(short analog)
{
    WORD_VAL w;

	// mInitPot();
	TRISAbits.TRISA5=1;
	ADCON0=(analog<<2)|1;
	ADCON2=0x3C;
	ADCON2bits.ADFM = 1;


    ADCON0bits.GO = 1;              // Start AD conversion
    while(ADCON0bits.NOT_DONE);     // Wait for conversion

    w.v[0] = ADRESL;
    w.v[1] = ADRESH;
 
    return w;
}

void main(void){

    InitializeSystem();
	
    #if defined(USB_INTERRUPT)
        USBDeviceAttach();
    #endif

	setup();

    while(1)
    {
        #if defined(USB_POLLING)
		// Check bus status and service USB interrupts.
        USBDeviceTasks(); 
        #endif

		tick++;	  
        loop();
    }
	
}

void setup(void)
{
	TRISA = 0x00;
	TRISB = 0x00;
	TRISD = 0x00;
}


void loop(void)
{
	processUsbCommands();
}

int lastSendTime = 0;
void send(void)
{
	WORD_VAL w;
	if (tick - lastSendTime < 100) return;
	lastSendTime = tick;

	ToSendDataBuffer[0] = PORTA;
	ToSendDataBuffer[1] = PORTD;
	ToSendDataBuffer[2] = PORTB;

	
	sendAnalogInputs();

	// Transmit the response to the host
    if(!HIDTxHandleBusy(USBInHandle))
	{
		USBInHandle = HIDTxPacket(HID_EP,(BYTE*)&ToSendDataBuffer[0],64);
	}
}

// Process USB commands
void processUsbCommands(void)
{   
    // Check if we are in the configured state; otherwise just return
    if((USBDeviceState < CONFIGURED_STATE) || (USBSuspendControl == 1))
    {
	    // We are not configured
	    return;
	}

	// Check if data was received from the host.
    if(!HIDRxHandleBusy(USBOutHandle))
    {   
		// Command mode    
        switch(ReceivedDataBuffer[0])
		{
			case 0x00:  // RQ_PIN_MODE (PIN, MODE)
				executePinMode();
				break;
			case 0x01:	// RQ_DIGITAL_WRITE (PIN, VAL)
				executeDigitalWrite();
				break;   	
			
            default:	// Unknown command received
           		break;
		}
        // Re-arm the OUT endpoint for the next packet
        USBOutHandle = HIDRxPacket(HID_EP,(BYTE*)&ReceivedDataBuffer,64);
  	}

	send();
}

void executeDigitalWrite(void)
{
	int pin = ReceivedDataBuffer[1];
	int value = ReceivedDataBuffer[2];
	
	switch(pin)
	{
		// Autogenerated with Squeak:
		// ==========================
		// 	Transcript clear.
		// 	pins := ((0 to: 4) collect: [:i | 'A', i asString]),
		// 				((0 to: 7) collect: [:i | 'D', i asString]),
		// 				((0 to: 7) collect: [:i | 'B', i asString]).	
		// 	(2 to: 6), #(19 20), #(21 22), (27 to: 30), (33 to: 40)
		// 		withIndexDo: [:pinNumber :index || str pin |
		// 			pin := pins at: index.
		// 			str := 'case 0x{1}:
		// 				PORT{2}bits.R{2}{3} = value;
		// 				break;' format: {pinNumber printStringBase: 16. pin first. pin second}.
		// 			Transcript tab; tab; show: str; cr.
		// 		].
		case 0x2:
			PORTAbits.RA0 = value;
			break;
		case 0x3:
			PORTAbits.RA1 = value;
			break;
		case 0x4:
			PORTAbits.RA2 = value;
			break;
		case 0x5:
			PORTAbits.RA3 = value;
			break;
		case 0x6:
			PORTAbits.RA4 = value;
			break;
		case 0x7:
			PORTAbits.RA5 = value;
			break;
		case 0x13:
			PORTDbits.RD0 = value;
			break;
		case 0x14:
			PORTDbits.RD1 = value;
			break;
		case 0x15:
			PORTDbits.RD2 = value;
			break;
		case 0x16:
			PORTDbits.RD3 = value;
			break;
		case 0x1B:
			PORTDbits.RD4 = value;
			break;
		case 0x1C:
			PORTDbits.RD5 = value;
			break;
		case 0x1D:
			PORTDbits.RD6 = value;
			break;
		case 0x1E:
			PORTDbits.RD7 = value;
			break;
		case 0x21:
			PORTBbits.RB0 = value;
			break;
		case 0x22:
			PORTBbits.RB1 = value;
			break;
		case 0x23:
			PORTBbits.RB2 = value;
			break;
		case 0x24:
			PORTBbits.RB3 = value;
			break;
		case 0x25:
			PORTBbits.RB4 = value;
			break;
		case 0x26:
			PORTBbits.RB5 = value;
			break;
		case 0x27:
			PORTBbits.RB6 = value;
			break;
		case 0x28:
			PORTBbits.RB7 = value;
			break;
		default: // Unknown pin
			break;
	}
}

void executePinMode(void)
{
	int pin = ReceivedDataBuffer[1];
	int value = ReceivedDataBuffer[2];
	
	switch (pin)
	{
		case 0x2:
			TRISAbits.RA0 = value;
			break;
		case 0x3:
			TRISAbits.RA1 = value;
			break;
		case 0x4:
			TRISAbits.RA2 = value;
			break;
		case 0x5:
			TRISAbits.RA3 = value;
			break;
		case 0x6:
			TRISAbits.RA4 = value;
			break;
		case 0x13:
			TRISDbits.RD0 = value;
			break;
		case 0x14:
			TRISDbits.RD1 = value;
			break;
		case 0x15:
			TRISDbits.RD2 = value;
			break;
		case 0x16:
			TRISDbits.RD3 = value;
			break;
		case 0x1B:
			TRISDbits.RD4 = value;
			break;
		case 0x1C:
			TRISDbits.RD5 = value;
			break;
		case 0x1D:
			TRISDbits.RD6 = value;
			break;
		case 0x1E:
			TRISDbits.RD7 = value;
			break;
		case 0x21:
			TRISBbits.RB0 = value;
			break;
		case 0x22:
			TRISBbits.RB1 = value;
			break;
		case 0x23:
			TRISBbits.RB2 = value;
			break;
		case 0x24:
			TRISBbits.RB3 = value;
			break;
		case 0x25:
			TRISBbits.RB4 = value;
			break;
		case 0x26:
			TRISBbits.RB5 = value;
			break;
		case 0x27:
			TRISBbits.RB6 = value;
			break;
		case 0x28:
			TRISBbits.RB7 = value;
			break;
	}
}


void sendAnalogInputs(void)
{
	WORD_VAL w;
	/// Autogenerated with Squeak:
	/// ##########################
	/// pins := #(A0 A1 A2 A3 A5 E0 E1 E2 B2 B3 B1 B4 B0) collect: [:each | 'TRIS', each].
	/// analogs := (0 to: 12).
	/// analogs with: pins do: [:an :tris || str |
	/// 	str := '	if ({1}bits.{2} == 1)
	/// 	\{
	/// 		w = ReadADC({3});
	/// 		ToSendDataBuffer[{4}] = w.v[0];
	/// 		ToSendDataBuffer[{5}] = w.v[1];
	/// 	\}' format: {
	/// 		tris first: 5.
	/// 		tris.
	/// 		an.
	/// 		an * 2 + 3.
	/// 		an * 2 + 4
	/// 	}.
	/// 	Transcript show: str; cr.
	/// ]

	if (TRISAbits.TRISA0 == 1)
	{
		w = ReadADC(0);
		ToSendDataBuffer[3] = w.v[0];
		ToSendDataBuffer[4] = w.v[1];
	}
	if (TRISAbits.TRISA1 == 1)
	{
		w = ReadADC(1);
		ToSendDataBuffer[5] = w.v[0];
		ToSendDataBuffer[6] = w.v[1];
	}
	if (TRISAbits.TRISA2 == 1)
	{
		w = ReadADC(2);
		ToSendDataBuffer[7] = w.v[0];
		ToSendDataBuffer[8] = w.v[1];
	}
	if (TRISAbits.TRISA3 == 1)
	{
		w = ReadADC(3);
		ToSendDataBuffer[9] = w.v[0];
		ToSendDataBuffer[10] = w.v[1];
	}
	if (TRISAbits.TRISA5 == 1)
	{
		w = ReadADC(4);
		ToSendDataBuffer[11] = w.v[0];
		ToSendDataBuffer[12] = w.v[1];
	}
	if (TRISEbits.TRISE0 == 1)
	{
		w = ReadADC(5);
		ToSendDataBuffer[13] = w.v[0];
		ToSendDataBuffer[14] = w.v[1];
	}
	if (TRISEbits.TRISE1 == 1)
	{
		w = ReadADC(6);
		ToSendDataBuffer[15] = w.v[0];
		ToSendDataBuffer[16] = w.v[1];
	}
	if (TRISEbits.TRISE2 == 1)
	{
		w = ReadADC(7);
		ToSendDataBuffer[17] = w.v[0];
		ToSendDataBuffer[18] = w.v[1];
	}
	if (TRISBbits.TRISB2 == 1)
	{
		w = ReadADC(8);
		ToSendDataBuffer[19] = w.v[0];
		ToSendDataBuffer[20] = w.v[1];
	}
	if (TRISBbits.TRISB3 == 1)
	{
		w = ReadADC(9);
		ToSendDataBuffer[21] = w.v[0];
		ToSendDataBuffer[22] = w.v[1];
	}
	if (TRISBbits.TRISB1 == 1)
	{
		w = ReadADC(10);
		ToSendDataBuffer[23] = w.v[0];
		ToSendDataBuffer[24] = w.v[1];
	}
	if (TRISBbits.TRISB4 == 1)
	{
		w = ReadADC(11);
		ToSendDataBuffer[25] = w.v[0];
		ToSendDataBuffer[26] = w.v[1];
	}
	if (TRISBbits.TRISB0 == 1)
	{
		w = ReadADC(12);
		ToSendDataBuffer[27] = w.v[0];
		ToSendDataBuffer[28] = w.v[1];
	}
}
