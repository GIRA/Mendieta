#include "USB_HID.h"
#include <delays.h>

void setup(void);
void loop(void);
void processUsbCommands(void);
void executeDigitalWrite(void);
void executePortMode(void);

void delay(void)
{
	int i;
	for (i=0; i<=1; i++)
	 {
	      Delay10KTCYx(250);   // Delay of 10000*250 Cycles
	 }
}

void main(void){

    InitializeSystem();
	
    #if defined(USB_INTERRUPT)
        USBDeviceAttach();
    #endif

	setup();

    while(1)
    {
        #if defined(USB_POLLING)
		// Check bus status and service USB interrupts.
        USBDeviceTasks(); 
        #endif
    				  
        loop();
    }
	
}

void setup(void)
{
	TRISA = 0;
	TRISB = 0;
	TRISD = 0;
}

void loop(void)
{
	processUsbCommands();
}


// Process USB commands
void processUsbCommands(void)
{   
    // Check if we are in the configured state; otherwise just return
    if((USBDeviceState < CONFIGURED_STATE) || (USBSuspendControl == 1))
    {
	    // We are not configured
	    return;
	}

	// Check if data was received from the host.
    if(!HIDRxHandleBusy(USBOutHandle))
    {   
		// Command mode    
        switch(ReceivedDataBuffer[0])
		{
			case 0x00:  // RQ_PORT_MODE (PORT, MODE)
				executePortMode();
				break;
			case 0x01:	// RQ_DIGITAL_WRITE (PIN, VAL)
				executeDigitalWrite();
				break;
            case 0x02:  // RQ_PORT_REPORT
				ToSendDataBuffer[0] = PORTA;
				ToSendDataBuffer[1] = PORTB;
				ToSendDataBuffer[2] = PORTC;
				ToSendDataBuffer[3] = PORTD;
				ToSendDataBuffer[4] = PORTE;

				// Transmit the response to the host
                if(!HIDTxHandleBusy(USBInHandle))
				{
					USBInHandle = HIDTxPacket(HID_EP,(BYTE*)&ToSendDataBuffer[0],64);
				}
            	break;            	
			
            default:	// Unknown command received
           		break;
		}
		 
        // Re-arm the OUT endpoint for the next packet
        USBOutHandle = HIDRxPacket(HID_EP,(BYTE*)&ReceivedDataBuffer,64);
  	}
}

void executeDigitalWrite(void)
{
	int pin = ReceivedDataBuffer[1];
	int value = ReceivedDataBuffer[2];
	
	switch(pin)
	{
		// Autogenerated with Squeak:
		// ==========================
		// 	Transcript clear.
		// 	pins := ((0 to: 4) collect: [:i | 'A', i asString]),
		// 				((0 to: 7) collect: [:i | 'D', i asString]),
		// 				((0 to: 7) collect: [:i | 'B', i asString]).	
		// 	(2 to: 6), #(19 20), #(21 22), (27 to: 30), (33 to: 40)
		// 		withIndexDo: [:pinNumber :index || str pin |
		// 			pin := pins at: index.
		// 			str := 'case 0x{1}:
		// 				PORT{2}bits.R{2}{3} = value;
		// 				break;' format: {pinNumber printStringBase: 16. pin first. pin second}.
		// 			Transcript tab; tab; show: str; cr.
		// 		].
		case 0x2:
			PORTAbits.RA0 = value;
			break;
		case 0x3:
			PORTAbits.RA1 = value;
			break;
		case 0x4:
			PORTAbits.RA2 = value;
			break;
		case 0x5:
			PORTAbits.RA3 = value;
			break;
		case 0x6:
			PORTAbits.RA4 = value;
			break;
		case 0x7:
			PORTAbits.RA5 = value;
			break;
		case 0x13:
			PORTDbits.RD0 = value;
			break;
		case 0x14:
			PORTDbits.RD1 = value;
			break;
		case 0x15:
			PORTDbits.RD2 = value;
			break;
		case 0x16:
			PORTDbits.RD3 = value;
			break;
		case 0x1B:
			PORTDbits.RD4 = value;
			break;
		case 0x1C:
			PORTDbits.RD5 = value;
			break;
		case 0x1D:
			PORTDbits.RD6 = value;
			break;
		case 0x1E:
			PORTDbits.RD7 = value;
			break;
		case 0x21:
			PORTBbits.RB0 = value;
			break;
		case 0x22:
			PORTBbits.RB1 = value;
			break;
		case 0x23:
			PORTBbits.RB2 = value;
			break;
		case 0x24:
			PORTBbits.RB3 = value;
			break;
		case 0x25:
			PORTBbits.RB4 = value;
			break;
		case 0x26:
			PORTBbits.RB5 = value;
			break;
		case 0x27:
			PORTBbits.RB6 = value;
			break;
		case 0x28:
			PORTBbits.RB7 = value;
			break;
		default: // Unknown pin
			break;
	}
}

void executePortMode(void)
{
	int port = ReceivedDataBuffer[1];
	int value = ReceivedDataBuffer[2];
	
	switch (port)
	{
		case 0:
			TRISA = value;
			break;
		case 1:
			TRISB = value;
			break;
		case 2:
			TRISD = value;
			break;
	}

}